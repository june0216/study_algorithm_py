## 정렬

- 데이터를 특정 기준에 따라서 순서대로 나열

## 선택 정렬

- 매번 가장 작은 것을 선택한다.
- 가장 작은 값을 찾아서 첫번째 자리에 넣는다.
- N개가 있을 때 앞으로 보내는 과정을 N-1번 반복하면 정렬이 완료된다.
- 시간 복잡도
    - N + (N-1) + (N-2) + (N-3) … + 1
    - ⇒ N * (N+1) / 2
    - 최악임

## 삽입정렬

- 데이터를 하나씩 확인하며 각 데이터를 적절한 위치에 삽입
    - 적절한 위치에 들어가기 이전에 그 앞까지의 데이터는 이미 정렬되어 있다고 가정
- 직관적으로 이해하기 쉬움
- 선택정렬에 비해 실행 시간 측면에서 더 효율적인 알고리즘
- 모든 원소를 비교하는 선택 정렬에 비해 필요할 때만 위치를 바꾸므로 효율적이다.
    - 데이터가 거의 정렬되어 있을 때 더 효율적일 것
- 삽입 정렬은 두 번째 데이터부터 시작한다
    - 첫 번째 데이터는 그 자체로 정렬되어 있다고 가정
- 시간 복잡도
    - O(N^2)
    - 하지만 거의 정렬되어 있는 상태라면 O(N)까지도 가능
        - 이는 퀵 정렬보다 빠름
        - 거의 정렬되어 있는 상태라면 삽입 정렬을 하자

## 퀵 정렬

- 가장 많이 사용되는 알고리즘
    - 정렬 라이브러리의 근간
- 기준을 정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸면?
- 피벗(기준)을 정하는 방법에 따라 여러 가지 방식으로 퀵 정렬을 구분
- 데이터가 무작위 → 빠르게 동작 , 정렬되어 있는 경우 → 느리게 동작

## 계수 정렬

- 특정 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘
    - 조건 = 데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을때만 사용 가능 + 중복적으로 등장할 때 유리
- 배열을 만들어서 해당 숫자가 나오면 값을 증가시킨다. → 인덱스 순서대로 숫자를 나열한다.
- 시간 복잡도 = O(N + K)

## 파이썬의 정렬 라이브러리

- sorted()
    - 퀵정렬과 비슷한 동작 방식
        - 일반적으로 퀵 정렬보다 느리지만 최악의 경우에 O(NlogN)을 보장한다는 특징이 있다.
    - 리스트, 딕셔너리 등을 입력 받아 → 결과를 “리스트”로 반환
- sort()
    - 리스트가 반환되는 것이 아니라 배열 내부원소가 바뀌는 것이다.
- key 매개 변수를 입력으로 받기
    - 정렬 기준
- 하이브리드 (삽입 + 병렬)
    - 이보다 빠르게 동작해야한다면 계수 정렬 알고리즘을 사용하자